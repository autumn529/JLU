# P1923 【深基9.例4】求第 k 小的数

## 题目描述

输入 $n$（$1 \le n < 5000000$ 且 $n$ 为奇数）个数字 $a_i$（$1 \le a_i < {10}^9$），输出这些数字的第 $k$ 小的数。最小的数是第 $0$ 小。

请尽量不要使用 `nth_element` 来写本题，因为本题的重点在于练习分治算法。

## 输入格式

第一行有两个整数，分别表示 $n$ 和 $k$。

第二行有 $n$ 个整数，第 $i$ 个数表示 $a_i$。

## 输出格式

一个整数，表示第 $k$ 小的数。

## 输入输出样例 #1

### 输入 #1

```
5 1
4 3 2 1 5
```

### 输出 #1

```C++
2
```



```C++
#include<iostream>
#include<vector>
using namespace std;
void qs(int l,int r,int k,vector<int>& num)
{
    int mid=(l+r)/2;
    int tmp=num[mid];
    int i=l,j=r;
    while(i<=j)
    {    
    	while(num[i]<num[mid])
    		i++;
    	while(num[j]>num[mid])
    		j--;
    	
        if(i<=j)
        {    
            swap(num[i],num[j]);
        	i++;
            j--;
        }
     }
    
    if(k<=j)
        return qs(l,j,k,num);
    else if(k>=i)
        return qs(i,r,k,num);
    else
    {
        cout<<num[k];
        return;
    }
}


int main(void)
{
    int n,k;
    cin>>n>>k;
    vector<int> num(n);
    for(int i=0;i<n;i++)
        cin>>num[i];
    
 	qs(0,n-1,k,num);
    
    return 0;
}
```



### 具体思路：

#### 分治思想：

  将数组划分为大于mid和小于mid的两个区间，两个区间不需要保证内部有序，只需保证整体上右区间大于左区间



```C++
    	while(num[i]<num[mid])//满足情况就跳过，直接i++,j--
    		i++;
    	while(num[j]>num[mid])
    		j--;
```

### 为什么这里没有等于情况？

严格保证划分好的左区间严格小于mid，右区间严格大于mid，while循环这里不能加等于情况，如果加上会导致相等的数全部被划分到左/右区间，导致索引混乱，甚至出现无限循环情况。



```c++
        if(i<=j)
        {    
            swap(num[i],num[j]);
        	i++;
            j--;
        }
```

不满足情况就交换，直接对数组进行交换操作，最终严格保证划分好的左区间严格小于mid，右区间严格大于mid



```C++
    if(k<=j)
        return qs(l,j,k,num);
    else if(k>=i)
        return qs(i,r,k,num);
    else
    {
        cout<<num[k];
        return;
    }
```

如果k落在左区间则递归左区间，如果在右区间则递归右区间，如果在中间，则说明找到了，直接输出即可。

