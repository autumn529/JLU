# 二叉树的操作



##### ==遍历方法==：

1.先根遍历

2.中根遍历

3.后根遍历

4.层次遍历

```C++
//先根遍历
void Preorder(Node* root)
{
    if(root==nullptr)
    return;
    
    cout<<root->val;
    Preorder(root->left);
    Preorder(root->right);
}
```

```C++
void LevelOrder(Node* root)
{
    queue<Node*> tree;
    if(root!=nullptr)
        tree.push(root);
    while(!tree.empty())
    {
        Node* tmp=tree.front();
        tree.pop();
        cout<<tmp->val;
        if(tmp->left!=nullptr)
            tree.push(tmp->left);
        if(tmp->right!=nullptr)
            tree.push(tmp->right);
    }
}
```





```C++
//搜索值为k的节点
Node* search(Node* root,int k)
{
    if(root==nullptr)
        return nullptr;
    if(root->val==k)
        return root;
    
    Node* ans=search(root->left,k);
    if(ans!=nullptr)
        return ans;
    return search(root->right,k);
}
```



```C++
//计算二叉树的节点
int Count(Node* root)
{
    if(root==nullptr)
        return 0;
    return Count(root->left)+Count(root->right)+1;
}
```



```C++
//计算二叉树高度
int depth(Node* root)
{
    if(root==nullptr)
        return -1;
    int d1=depth(root->left);
    int d2=depth(root->right);
    return (d1>d2)?d1+1:d2+1;
}
```



```C++
//删除二叉树
void Del(Node* &root)
{
    if(root==nullptr)
        return;
    
    Del(root->left);
    Del(root->right);
    
    delete root;
    root=nullptr;
}
```



```C++
bool DelTree(Node* &root,Node* p)
{
    if(root==nullptr||p==nullptr)
        return false;
    if(p==root)
    {
        Del(p);
    	return true;
    }
    
    if(DelTree(root->left,p))
        return true;
    else
        return DelTree(root->right,p);
}
```



```C++
int k=0;
Node* Create(char ch[])
{
    char tmp=ch[k++];
    if(tmp=='#')
        return nullptr;
    
    root->val=tmp;
    Node* root=new Node;
    root->left=Create(ch);
    root->right=Create(ch);
    return root;
}
```

