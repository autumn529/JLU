## 二叉树的遍历

1. 前序遍历
2. 中序遍历
3. 后序遍历
4. 层次遍历



前序和中序遍历可唯一确定一棵二叉树，中序和后序遍历也可以，先序和后序不可以

![4c8436189b94f6b41032ff5a036aa701](F:\files\WeChat\xwechat_files\wxid_11h7o9vocxfg22_1158\temp\RWTemp\2025-10\9e20f478899dc29eb19741386f9343c8\4c8436189b94f6b41032ff5a036aa701.png)



![a4055c659a55c56ca03c9676ebde58f4](F:\files\WeChat\xwechat_files\wxid_11h7o9vocxfg22_1158\temp\RWTemp\2025-10\9e20f478899dc29eb19741386f9343c8\a4055c659a55c56ca03c9676ebde58f4.png)



![ff9f820a467c3cc924c9f93cc90a290f](F:\files\WeChat\xwechat_files\wxid_11h7o9vocxfg22_1158\temp\RWTemp\2025-10\9e20f478899dc29eb19741386f9343c8\ff9f820a467c3cc924c9f93cc90a290f.png)



```C++
//先根遍历
void Preorder(Node* root)
{
    if(root==nullptr)
    return;
    
    cout<<root->val;
    Preorder(root->left);
    Preorder(root->right);
}
```

```C++
void LevelOrder(Node* root)
{
    queue<Node*> tree;
    if(root!=nullptr)
        tree.push(root);
    while(!tree.empty())
    {
        Node* tmp=tree.front();
        tree.pop();
        cout<<tmp->val;
        if(tmp->left!=nullptr)
            tree.push(tmp->left);
        if(tmp->right!=nullptr)
            tree.push(tmp->right);
    }
}
```





```C++
//搜索值为k的节点
Node* search(Node* root,int k)
{
    if(root==nullptr)
        return nullptr;
    if(root->val==k)
        return root;
    
    Node* ans=search(root->left,k);
    if(ans!=nullptr)
        return ans;
    return search(root->right,k);
}
```



```C++
//计算二叉树的节点
int Count(Node* root)
{
    if(root==nullptr)
        return 0;
    return Count(root->left)+Count(root->right)+1;
}
```



```C++
//计算二叉树高度
int depth(Node* root)
{
    if(root==nullptr)
        return -1;
    int d1=depth(root->left);
    int d2=depth(root->right);
    return (d1>d2)?d1+1:d2+1;
}
```



```C++
//删除二叉树
void Del(Node* &root)
{
    if(root==nullptr)
        return;
    
    Del(root->left);
    Del(root->right);
    
    delete root;
    root=nullptr;
}
```



```C++
bool DelTree(Node* &root,Node* p)
{
    if(root==nullptr||p==nullptr)
        return false;
    if(p==root)
    {
        Del(p);
    	return true;
    }
    
    if(DelTree(root->left,p))
        return true;
    else
        return DelTree(root->right,p);
}
```



```C++
int k=0;
Node* Create(char ch[])
{
    char tmp=ch[k++];
    if(tmp=='#')
        return nullptr;
    
    root->val=tmp;
    Node* root=new Node;
    root->left=Create(ch);
    root->right=Create(ch);
    return root;
}
```







## 二叉树非递归遍历

```C++
void NPreOrder(Node* root)
{
    stack<Node*> s;
    Node* p=root;
    
    while(1)
    {
        while(p!=nullptr)
        {
            cout<<p->val<<" ";
            s.push(p);
            p=p->left;
        }
        
        if(s.empty())
            return;
        
        p=s.top();
        s.pop();
        p=p->right;
    }
}
```



