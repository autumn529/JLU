# 线索二叉树

中根线索二叉树为例

​		Left|Data|Right

如果某结点：

➢有子结点，则其Left/Right指向子结点

➢无子结点，则其Left/Right指向其中根前驱/后继



![69fdc68992d0f8c91c3caf90dbc8e198](F:\files\WeChat\xwechat_files\wxid_11h7o9vocxfg22_1158\temp\RWTemp\2025-10\9e20f478899dc29eb19741386f9343c8\69fdc68992d0f8c91c3caf90dbc8e198.png)



![ba1e9a1f820fa789d2d10a75b3372d90](F:\files\WeChat\xwechat_files\wxid_11h7o9vocxfg22_1158\temp\RWTemp\2025-10\9e20f478899dc29eb19741386f9343c8\ba1e9a1f820fa789d2d10a75b3372d90.png)





线索二叉树的目的：

在中序线索二叉树中可以方便的找到给定结点的中序前驱和中序后继结点， 并且不需要太多额外的空间。

线索二叉树中，==一个结点是叶结点的充要条件==为：左、右标志(LThread、 RThread)均是1。







### 基本操作

找线索二叉树的中根序列的第一个/最后一个结点 

```C++
Node* FirstInorder(Node* root)
{
    if(root==nullptr)
        return;
    Node* ans=root;
    while(ans->Lthread==0)
        ans=ans->left;
    return ans;
}

Node* LastInorder(Node* root)
{
    if(root==nullptr)
        return;
    Node* ans=root;
    while(ans->Rthread==0)
        ans=ans->right;
    return ans;
}
```



在中序线索二叉树中，找结点p的中根前驱/后继结点 

```C++
Node* PreInorder(Node* root)
{
    if(root==nullptr);
    return nullptr;
    if(root->Lthread==1)
        return root->left;
    return LastInorder(root->left);
}


Node* NextInorder(Node* root)
{
    if(root==nullptr)
        return nullptr;
    if(root->Rthread==1)
        return root->right;
    return FirstInorder(root->right);
}
```

 

中根遍历线索二叉树

```C++
void InOrder(Node* root)
{
    Node* tmp=FirstInorder(root);
    while(tmp!=nullptr)
    {
        cout<<tmp->val<<" ";
        tmp=NextInorder(tmp);
    }
}
```



二叉树中序遍历线索化

```C++
Node* pre=nullptr;
void threading(Node* root)
{
    if(root==nullptr)
        return;
    
    threading(root->left);
    
    if(root->left==nullptr)
    {
        root->Lthread=1;
        root->left=pre;
    }
    else
        root->Lthread=0;
    
    
    if(pre!=nullptr&&pre->left==nullptr)
    {
        pre->Rthread=1;
        pre->right=root;
    }
    else if(pre!=nullptr)
    	pre->Rthread=0;
    
    pre=root;
    
    threading(root->right);
}
//算法结束后要调整中序最后一个结点（pre指向）的右线索:
pre->Rthread=1;
```





### ==二叉树中序遍历搜索化==

![fd2e83c67415b7a8dea9aa6fdfb8207a](F:\files\WeChat\xwechat_files\wxid_11h7o9vocxfg22_1158\temp\RWTemp\2025-10\9e20f478899dc29eb19741386f9343c8\fd2e83c67415b7a8dea9aa6fdfb8207a.png)







![b0c1a18f11a0af5aa3382dd3b5751d94](F:\files\WeChat\xwechat_files\wxid_11h7o9vocxfg22_1158\temp\RWTemp\2025-10\9e20f478899dc29eb19741386f9343c8\b0c1a18f11a0af5aa3382dd3b5751d94.png)





![e9c685f1b109f74c1a29acc49d01ac62](F:\files\WeChat\xwechat_files\wxid_11h7o9vocxfg22_1158\temp\RWTemp\2025-10\9e20f478899dc29eb19741386f9343c8\e9c685f1b109f74c1a29acc49d01ac62.png)





![00808f9a30aaba142064bf5b01330ea1](F:\files\WeChat\xwechat_files\wxid_11h7o9vocxfg22_1158\temp\RWTemp\2025-10\9e20f478899dc29eb19741386f9343c8\00808f9a30aaba142064bf5b01330ea1.png)



